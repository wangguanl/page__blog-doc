import{_ as s,v as a,b as n,R as l}from"./chunks/framework.4f207390.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"构建工具/webpack/modules.md","filePath":"构建工具/webpack/modules.md","lastUpdated":1676277717000}'),e={name:"构建工具/webpack/modules.md"},o=l(`<ol><li>使用 require 引入 ESM 文件，会将文件内容全部同步引入</li><li>require 引入的内容支持被结构，满足 ESM import 规范</li></ol><h2 id="引入模块-合并打包还是单独打包-import-和-require" tabindex="-1">引入模块（合并打包还是单独打包），import 和 require <a class="header-anchor" href="#引入模块-合并打包还是单独打包-import-和-require" aria-label="Permalink to &quot;引入模块（合并打包还是单独打包），import 和 require&quot;">​</a></h2><ol><li>import 和 require 引入的文件是将文件代码合并到执行命令的文件中</li><li>使用 import(url) 引入的文件会将文件单独打包，如果这个文件依赖执行命令文件的其他同步依赖，共同依赖不会被打包</li><li>如果是异步的通用依赖，会被重复打包</li></ol><h2 id="引入单个目标文件" tabindex="-1">引入单个目标文件 <a class="header-anchor" href="#引入单个目标文件" aria-label="Permalink to &quot;引入单个目标文件&quot;">​</a></h2><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 假设：如果不使用 import 的变量则不会被打包进入 ： require引入后就一定会被打包</span></span>
<span class="line"><span style="color:#82AAFF;">import</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">/* webpackChunkName: &quot;my-chunk-name&quot; */</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 新 chunk 的名称。 从 webpack 2.6.0 开始，占位符 [index] 和 [request] 分别支持递增的数字或实际的解析文件名。 添加此注释后，将单独的给我们的 chunk 命名为 [my-chunk-name].js 而不是 [id].js</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">/* webpackExports: [&quot;default&quot;, &quot;named&quot;] */</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 告知 webpack 只构建指定出口的动态 import() 模块。它可以减小 chunk 的大小</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">/* webpackPrefetch: true */</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 告诉浏览器将来可能需要该资源来进行某些导航跳转 // https://webpack.docschina.org/guides/code-splitting/#prefetchingpreloading-modules</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">/* webpackPreload: true */</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 告诉浏览器在当前导航期间可能需要该资源 https://webpack.docschina.org/guides/code-splitting/#prefetchingpreloading-modules</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">/* webpackMode: &quot;lazy&quot; */</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">module</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><h2 id="引入多个可能的目标文件-满足以下规则则会被打包" tabindex="-1">引入多个可能的目标文件（满足以下规则则会被打包） <a class="header-anchor" href="#引入多个可能的目标文件-满足以下规则则会被打包" aria-label="Permalink to &quot;引入多个可能的目标文件（满足以下规则则会被打包）&quot;">​</a></h2><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">import</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">/* webpackInclude: /\\.json$/ */</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 在导入解析（import resolution）过程中，用于匹配的正则表达式。只有匹配到的模块才会被打包</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">/* webpackExclude: /\\.noimport\\.json$/ */</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 在导入解析（import resolution）过程中，用于匹配的正则表达式。所有匹配到的模块都不会被打包</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">./locale/</span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">language</span><span style="color:#89DDFF;">}\`</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><h2 id="webpackmode-从-webpack-2-6-0-开始-可以指定以不同的模式解析动态导入。支持以下选项" tabindex="-1">webpackMode：从 webpack 2.6.0 开始，可以指定以不同的模式解析动态导入。支持以下选项： <a class="header-anchor" href="#webpackmode-从-webpack-2-6-0-开始-可以指定以不同的模式解析动态导入。支持以下选项" aria-label="Permalink to &quot;webpackMode：从 webpack 2.6.0 开始，可以指定以不同的模式解析动态导入。支持以下选项：&quot;">​</a></h2><ol><li><strong>lazy</strong> (默认值)：为每个 import() 导入的模块生成一个可延迟加载（lazy-loadable）的 chunk。</li><li><strong>lazy-once</strong>：生成一个可以满足所有 import() 调用的单个可延迟加载（lazy-loadable）的 chunk。此 chunk 将在第一次 import() 时调用时获取，随后的 import() 则使用相同的网络响应。注意，这种模式仅在部分动态语句中有意义，例如 import(<code>./locales/\${language}.json</code>)，其中可能含有多个被请求的模块路径。</li><li><strong>eager</strong>：不会生成额外的 chunk。所有的模块都被当前的 chunk 引入，并且没有额外的网络请求。但是仍会返回一个 resolved 状态的 Promise。与静态导入相比，在调用 import() 完成之前，该模块不会被执行。</li><li><strong>weak</strong>：尝试加载模块，如果该模块函数已经以其他方式加载，（即另一个 chunk 导入过此模块，或包含模块的脚本被加载）。仍会返回 Promise， 但是只有在客户端上已经有该 chunk 时才会成功解析。如果该模块不可用，则返回 rejected 状态的 Promise，且网络请求永远都不会执行。当需要的 chunks 始终在（嵌入在页面中的）初始请求中手动提供，而不是在应用程序导航在最初没有提供的模块导入的情况下触发，这对于通用渲染（SSR）是非常有用的。</li></ol><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 创建一个项目的模块依赖关系</span></span>
<span class="line"><span style="color:#A6ACCD;">require</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">ensure</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  dependencies: String[]</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 字符串数组，声明 callback 回调函数中所需要的所有模块。</span></span>
<span class="line"><span style="color:#A6ACCD;">  callback: </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">require</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">,  </span><span style="color:#676E95;font-style:italic;">// 当依赖项加载完成后，webpack 将会执行此函数，require 函数的实现，作为参数传入此函数中。当程序运行需要依赖时，可以使用 require() 来加载依赖。函数体可以使用此参数，来进一步执行 require() 模块。</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#82AAFF;">errorCallback</span><span style="color:#A6ACCD;">: </span><span style="color:#82AAFF;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">error</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">, </span><span style="color:#676E95;font-style:italic;">// 当 webpack 加载依赖失败时会执行此函数。</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#82AAFF;">chunkName</span><span style="color:#A6ACCD;">: </span><span style="color:#82AAFF;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 由 require.ensure 创建的 chunk 的名称。通过将相同 chunkName 传递给不同的 require.ensure 调用，我们可以将其代码合并到一个单独的 chunk 中，从而只产生一个浏览器必须加载的 bundle。</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span></code></pre></div>`,10),p=[o];function t(c,r,i,y,u,A){return a(),n("div",null,p)}const D=s(e,[["render",t]]);export{d as __pageData,D as default};
