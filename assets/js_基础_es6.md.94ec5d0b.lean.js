import{_ as a,v as e,b as r,R as t}from"./chunks/framework.4f207390.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"js/基础/es6.md","filePath":"js/基础/es6.md","lastUpdated":1664359331000}'),o={name:"js/基础/es6.md"},i=t('<p><a href="https://es6.ruanyifeng.com/" target="_blank" rel="noreferrer">阮一峰ES6教程</a><br><a href="https://www.wangdoc.com/es6/intro.html" target="_blank" rel="noreferrer">网道ES6教程</a></p><h2 id="声明变量" tabindex="-1">声明变量 <a class="header-anchor" href="#声明变量" aria-label="Permalink to &quot;声明变量&quot;">​</a></h2><p>增加了块级作用域、模块的概念。 let 声明变量和 const 声明常量，两个都有块级作用域。<br> ES5 中是没有块级作用域的，并且 var 有变量提升，在let中，使用的变量一定要提前声明。</p><h2 id="箭头函数" tabindex="-1">箭头函数 <a class="header-anchor" href="#箭头函数" aria-label="Permalink to &quot;箭头函数&quot;">​</a></h2><ul><li>函数内是没有 this 的，调用时会自动向上查找 this， 由上下文来确定 this 。</li><li>不能使用 new 关键字</li><li>不能使用 arguments 关键字</li><li>不可以使用yield命令，因此箭头函数不能用作 Generator 函数</li></ul><h2 id="模板字符串" tabindex="-1">模板字符串 <a class="header-anchor" href="#模板字符串" aria-label="Permalink to &quot;模板字符串&quot;">​</a></h2><p>模板字符串是增强版的字符串，用反引号（`）标识，可以当作普通字符串使用，也可以用来定义多行字符串。使用 ${} 代替反斜杠</p><h2 id="数组对象解构赋值" tabindex="-1">数组对象解构赋值 <a class="header-anchor" href="#数组对象解构赋值" aria-label="Permalink to &quot;数组对象解构赋值&quot;">​</a></h2><h2 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-label="Permalink to &quot;Promise&quot;">​</a></h2><p>三个状态：pending、fulfilled、reject 两个过程：padding -&gt; fulfilled、padding -&gt; rejected当pending为rejectd时，会进入catch</p><h2 id="async-await" tabindex="-1">async／await <a class="header-anchor" href="#async-await" aria-label="Permalink to &quot;async／await&quot;">​</a></h2><p>将链式调用变得更加简化， 是因为 async 函数是 Generator 函数的语法糖， 容易理解， 而且和 promise 函数也有很大的关联</p><h2 id="generator-管理异步回调的执行流程。" tabindex="-1">generator 管理异步回调的执行流程。 <a class="header-anchor" href="#generator-管理异步回调的执行流程。" aria-label="Permalink to &quot;generator 管理异步回调的执行流程。&quot;">​</a></h2><h2 id="settimeout、promise、async-await-的区别" tabindex="-1">setTimeout、Promise、Async/Await 的区别 <a class="header-anchor" href="#settimeout、promise、async-await-的区别" aria-label="Permalink to &quot;setTimeout、Promise、Async/Await 的区别&quot;">​</a></h2><p>事件循环中分为宏任务队列和微任务队列 其中setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行async函数表示函数里面可能会有异步方法，await后面跟一个表达式 async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行</p><h2 id="理解-async-await以及对generator的优势" tabindex="-1">理解 async/await以及对Generator的优势 <a class="header-anchor" href="#理解-async-await以及对generator的优势" aria-label="Permalink to &quot;理解 async/await以及对Generator的优势&quot;">​</a></h2><p>async await 是用来解决异步的，async函数是Generator函数的语法糖 使用关键字async来表示，在函数内部使用 await 来表示异步 async函数返回一个 Promise 对象，可以使用then方法添加回调函数 当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句 <strong>async较Generator的优势：</strong> （1）内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样 （2）更好的语义。async 和 await 相较于 * 和 yield 更加语义化　　 （3）更广的适用性。yield命令后面只能是 Thunk 函数或 Promise对象，async函数的await后面可以是Promise也可以是原始类型的值 （4）返回值是 Promise。async 函数返回的是 Promise 对象，比Generator函数返回的Iterator对象方便，可以直接使用 then() 方法进行调用</p><h2 id="proxy" tabindex="-1">Proxy <a class="header-anchor" href="#proxy" aria-label="Permalink to &quot;Proxy&quot;">​</a></h2><h2 id="class" tabindex="-1">Class <a class="header-anchor" href="#class" aria-label="Permalink to &quot;Class&quot;">​</a></h2><p>ES6的 Class 可以看作是一个语法糖，它的绝大部分功能 ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法</p><ul><li>抽象</li><li>面向对象三大特性 <ul><li>封装</li><li>继承</li><li>多态</li></ul></li></ul><h2 id="import、export" tabindex="-1">import、export <a class="header-anchor" href="#import、export" aria-label="Permalink to &quot;import、export&quot;">​</a></h2><p>将 JS 代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用</p><h2 id="symbol" tabindex="-1">Symbol <a class="header-anchor" href="#symbol" aria-label="Permalink to &quot;Symbol&quot;">​</a></h2><p>是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的</p><h2 id="set、map" tabindex="-1">Set、Map <a class="header-anchor" href="#set、map" aria-label="Permalink to &quot;Set、Map&quot;">​</a></h2><p>数据结构类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数。 应用场景Set用于数据重组，Map用于数据储存Set：　 （1）成员不能重复 （2）只有键值没有键名，类似数组 （3）可以遍历，方法有add, delete,has Map: （1）本质上是健值对的集合，类似集合 （2）可以遍历，可以跟各种数据格式转换</p><p>去重：Array.from(new Set(arr))，[...new Set(arr)]</p><h2 id="for-of循环-for-of-循环可以遍历数组、set和map结构、某些类似数组的对象、对象-以及字符串" tabindex="-1">for of循环 for...of 循环可以遍历数组、Set和Map结构、某些类似数组的对象、对象，以及字符串 <a class="header-anchor" href="#for-of循环-for-of-循环可以遍历数组、set和map结构、某些类似数组的对象、对象-以及字符串" aria-label="Permalink to &quot;for of循环 for...of 循环可以遍历数组、Set和Map结构、某些类似数组的对象、对象，以及字符串&quot;">​</a></h2>',29),s=[i];function n(l,h,c,d,p,m){return e(),r("div",null,s)}const b=a(o,[["render",n]]);export{f as __pageData,b as default};
