import{_ as a,v as e,b as s,R as r}from"./chunks/framework.4f207390.js";const S=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"框架/serverless/index.md","filePath":"框架/serverless/index.md","lastUpdated":1663229156000}'),i={name:"框架/serverless/index.md"},l=r('<h2 id="serverless解决了什么问题" tabindex="-1">ServerLess解决了什么问题？ <a class="header-anchor" href="#serverless解决了什么问题" aria-label="Permalink to &quot;ServerLess解决了什么问题？&quot;">​</a></h2><ul><li>无需运维</li><li>服务器配置弹性伸缩</li><li>按量付费，节省成本</li><li>更高的安全性</li><li>易于迭代，开发者可以不用关心服务器运维等方面的问题，可以专心效力于业务</li></ul><p>图片存储 -&gt; 对象存储</p><p>容器技术（docker） 替代 虚拟技术，在虚拟技术的基础上，把代码和运行环境绑在一起，无论服务器的运行配置如何，代码和运行环境始终保持一致。 当容器多的时候如何管理，出现了K8S</p><h2 id="名词" tabindex="-1">名词 <a class="header-anchor" href="#名词" aria-label="Permalink to &quot;名词&quot;">​</a></h2><h3 id="baas-后端即服务-backend-as-a-service" tabindex="-1">BaaS (后端即服务) (Backend as a Service) <a class="header-anchor" href="#baas-后端即服务-backend-as-a-service" aria-label="Permalink to &quot;BaaS (后端即服务) (Backend as a Service)&quot;">​</a></h3><p>提供Redis、SQL、等黑盒环境（黑盒：你不需要知道我是怎么实现的，你只管调用就行，开发者对底层服务器是无感知的）</p><h3 id="faas-函数即服务-function-as-a-service" tabindex="-1">FaaS (函数即服务) (Function as a Service) <a class="header-anchor" href="#faas-函数即服务-function-as-a-service" aria-label="Permalink to &quot;FaaS (函数即服务) (Function as a Service)&quot;">​</a></h3><p>运行业务逻辑代码（比如Node环境运行Js），调用BaaS环境提供的Redis、SQL等接口，由BaaS负责环境的调度和运维。</p><h3 id="serverless就是-faas-baas-的组合" tabindex="-1">ServerLess就是 FaaS + BaaS 的组合 <a class="header-anchor" href="#serverless就是-faas-baas-的组合" aria-label="Permalink to &quot;ServerLess就是 FaaS + BaaS 的组合&quot;">​</a></h3><ul><li><p>应用就是一套环境</p></li><li><p>BFF (Backend for Frontend) (使用node整合后端提供的接口，作为中间件使用)</p></li><li><p>Serverless Framework、Vercel、</p></li><li><p>函数计算、云函数</p></li></ul>',11),t=[l];function n(o,d,c,h,p,v){return e(),s("div",null,t)}const f=a(i,[["render",n]]);export{S as __pageData,f as default};
