import{_ as i,v as l,b as e,R as t}from"./chunks/framework.4f207390.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"面试题/优化/css.md","filePath":"面试题/优化/css.md","lastUpdated":1663229156000}'),o={name:"面试题/优化/css.md"},s=t('<ol><li>将样式表放到页面顶部</li><li>不使用CSS表达式</li><li>不使用 @import</li><li>避免回流重绘</li></ol><ul><li>回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。</li><li>重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。</li><li>优化方式 <ul><li>用 transion 去处理动画， 避免使用 top，left ，margin-top， margin-left… 这些位移属性</li><li>用 opacity 代替 visibility 站位隐藏</li><li>一次性修改 dom， 如果对 dom 的操作较多， 可以创建一个 class 进行收集，然后赋值给 dom</li><li>不要在循环内获取dom 的样式例如：offsetWidth, offsetHeight, clientWidth, clientHeight… 这些，使用变量存储获取的值。浏览器有一个回流的缓冲机制，即多个回流会保存在一个栈里面，当这个栈满了浏览器便会一次性触发所有样式的更改且刷新这个栈。但是如果你多次获取这些元素的实际样式，浏览器为了给你一个准确的答案便会不停刷新这个缓冲栈，导致页面回流增加。所以为了避免这个问题，应该用一个变量保存在循环体外。</li><li>不要使用table 布局，因为table 的每一个行甚至每一个单元格的样式更新都会导致整个table 重新布局</li><li>使用脱离文档流， 修改 dom 时不影响其他元素</li><li>使用 document.createDocumentFragment() 插入多个dom</li></ul></li></ul><h2 id="减少重排重绘" tabindex="-1">减少重排重绘 <a class="header-anchor" href="#减少重排重绘" aria-label="Permalink to &quot;减少重排重绘&quot;">​</a></h2><p>以下三种情况会导致页面重新渲染</p><ul><li>修改DOM</li><li>修改样式</li><li>用户事件</li></ul><p>重新渲染就是重新布局和重新绘制，前者叫重排（reflow），后者叫重绘（repaint）。 重排和重绘会影响页面性能以及用户使用体验，所以需要尽量降低重排和重绘的频率，需要注意以下几个方面。</p><ul><li>多个 DOM 的读操作尽量写在一起，不要在连续读操作中添加写操作。</li><li>如果样式是重排得到的，尽量缓存样式。</li><li>不要单一改变样式，最好通过 Class 统一改变。</li><li>尽量使用离线 DOM 来改变样式，完成后再将对象写入。</li><li>先将元素置为<code>display: none</code>，再对节点进行操作。</li><li>position 为 <code>absolute</code> 或 <code>fixed</code> 的元素重排开销比较下，因为不考虑其他元素的影响。</li><li>display:none 的节点不会被加入Render Tree, 而 visibility:hidden则会，所以，如果某个节点最开始是不显示的，设为display:none 是更优的。</li></ul>',7),a=[s];function d(n,c,r,p,m,u){return l(),e("div",null,a)}const _=i(o,[["render",d]]);export{h as __pageData,_ as default};
