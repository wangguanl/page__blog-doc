import{_ as e,v as i,b as t,R as a}from"./chunks/framework.4f207390.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"面试题/vue/Vue2和3.md","filePath":"面试题/vue/Vue2和3.md","lastUpdated":1660556470000}'),l={name:"面试题/vue/Vue2和3.md"},r=a('<h2 id="vue、react、angular-哪个更好" tabindex="-1">Vue、React、Angular 哪个更好？ <a class="header-anchor" href="#vue、react、angular-哪个更好" aria-label="Permalink to &quot;Vue、React、Angular 哪个更好？&quot;">​</a></h2><ul><li><p>与其说哪个更好，主要是看社区更发达为主要优点之一</p></li><li><p>Vue 集成了 React 和 Angular 的优点，通过vue核心去对比三大框架。</p><ul><li>集成了 Angular 的哪些优点</li><li>相比之下与不如 Angular</li><li>集成了 React 的哪些优点</li><li>相比之下与不如 React</li></ul></li><li><p>Vue 和 React 都可以完成相同的事情。 两者都是JS嘛， 但是React偏向于底层JS， 而Vue框架内提供了大量的API，偏向于Jquery。但是Vue3新推出了compositionAPI（组合式开发）更加融合了Vue集合了Angular、React两者的优点，对新接触框架的人更友好。</p></li><li><p>react不算是真正意义上的框架， 而是一种开发范式。 它的核心思想非常简单：</p><p>界面/视图就是数据结构的可视化表达 UI = f(data)</p><p>而界面/视图由组件组合而来 UI = f1(data) + f2(data) + f3(data) + ...</p><p>That&#39;s all.</p><p>三大框架整体的核心思想都是源于数据驱动（MVVM）</p></li><li><p><a href="https://juejin.cn/post/6850037277675454478#heading-1" target="_blank" rel="noreferrer">https://juejin.cn/post/6850037277675454478#heading-1</a></p></li></ul><h2 id="vue2-和-vue3-的区别" tabindex="-1">Vue2 和 Vue3 的区别 <a class="header-anchor" href="#vue2-和-vue3-的区别" aria-label="Permalink to &quot;Vue2 和 Vue3 的区别&quot;">​</a></h2><ul><li>更好的支持 typescript</li><li>底层，使用了Proxy <ol><li>Vue3 使用 Proxy，Proxy 代理是针对整个对象，而不是对象的某个属性，因此不同于 <code>Object.defineProperty</code> 的必须遍历对象每个属性，<code>Proxy</code> 只需要做一层代理就可以监听同级结构下的所有属性变化，当然对于深层结构，递归还是需要进行的。此外 Proxy 还支持代理数组变化。</li><li>Object.defineProperty 在一个对象上定义一个新属性或者修改一个已经存在的属性，使用 getter/setter 监听这个属性的变化。Object.defineProperty 的缺陷三个： <ul><li>不能监听数组的变化，需要使用函数拦截处理数组的 push、pop、shift、unshift、revers、sort、splice 方法</li><li>必须遍历对象的每个属性</li><li>必须深层遍历嵌套的对象</li></ul></li></ol></li><li>API：几大改动，细小改动</li><li>疑点： <ul><li>provide/inject</li><li>computed</li><li>watch</li><li>watchEffect</li><li>resolveDirective</li><li>withDirectives</li><li>createRenderer 更多可以看 vue2 迁移 <a href="https://vue-docs-next-zh-cn.netlify.app/guide/migration/introduction.html#%E6%A6%82%E8%A7%88" target="_blank" rel="noreferrer">https://vue-docs-next-zh-cn.netlify.app/guide/migration/introduction.html#概览</a> 不建议保留对原始对象的持久引用。请谨慎使用。返回的 proxy 是不等于原始对象的。建议只使用响应式 proxy，避免依赖原始对象</li><li>分清楚 Vue3 新特性 和 Vue2 与 Vue3 对应API的改动</li></ul></li></ul><h2 id="自定义-hook" tabindex="-1">自定义 hook <a class="header-anchor" href="#自定义-hook" aria-label="Permalink to &quot;自定义 hook&quot;">​</a></h2><p>抽离可复用的功能，框架提供一些内置函数，在 hook 里可以调用，让这个功能拥有组件状态。 更加是弥补了 mixin、extend 的缺点：不清楚暴露出来的变量的作用、命名冲突、重用低效。mixin属于隐式使用，hooks更强调与先声明后使用。</p><h2 id="为什么使用-composition-api" tabindex="-1">为什么使用 Composition API <a class="header-anchor" href="#为什么使用-composition-api" aria-label="Permalink to &quot;为什么使用 Composition API&quot;">​</a></h2><ul><li><a href="https://blog.csdn.net/wu_xianqiang/article/details/104417875" target="_blank" rel="noreferrer">https://blog.csdn.net/wu_xianqiang/article/details/104417875</a></li><li><a href="https://blog.csdn.net/u011068996/article/details/111337403" target="_blank" rel="noreferrer">https://blog.csdn.net/u011068996/article/details/111337403</a></li></ul><h2 id="jsx-语法开发与传统开发有什么区别-包含了-为什么使用jsx语法开发" tabindex="-1">JSX 语法开发与传统开发有什么区别（包含了 为什么使用JSX语法开发） <a class="header-anchor" href="#jsx-语法开发与传统开发有什么区别-包含了-为什么使用jsx语法开发" aria-label="Permalink to &quot;JSX 语法开发与传统开发有什么区别（包含了 为什么使用JSX语法开发）&quot;">​</a></h2><p>因为 JSX 语法符合 Vnode 的抽象思维，更加贴近 Vue 原生底层结构，思想和结构更加清晰明了。JSX 应用起来更加灵活。</p>',10),o=[r];function n(u,s,c,p,h,d){return i(),t("div",null,o)}const x=e(l,[["render",n]]);export{g as __pageData,x as default};
